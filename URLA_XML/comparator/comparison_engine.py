import typing

import prettytable
from models.singular_xml_element_base_model import BaseDealElement
from models.urla_xml_model import UrlaXML


class DataMatch:
    """ Simple data tracking class for mapping source entry to matching comparison entry """
    def __init__(self, id_set, source_obj: BaseDealElement, found=False,
                 match_obj: BaseDealElement = None) -> typing.NoReturn:
        """

        :param id_set: XPATH set and value (':' delimited)
        :param source_obj: Source Inherited BaseDealElement
        :param found: (bool) True = match found
        :param match_obj: If match is True, the corresponding Comparison BaseDealElement

        """
        self.id_set = id_set
        self.source_obj = source_obj
        self.found = found
        self.match_obj = match_obj


class ComparisonEngine:
    def __init__(self, primary: UrlaXML, comparison: UrlaXML):
        self.primary = primary
        self.comparison = comparison

    def compare_and_map_singular_elements(self, element_name: str, details: bool = False) -> typing.List[DataMatch]:
        """
        Compare the source and comparison elements for a given DealElement type. If a match is found, map the
        indices.

        e.g.
           - Src DealElement index 0 maps to Cmp DealElement index 7,
           - and the inverse, Cmp DealElement index 7 maps to Src DealElement index 0

        :param element_name: name of DealElement type to compare (should be plural, so all singular elems are compared).
        :param details: (boolean) - If True, generate a summary report

        :return: List of Src DataMatch objects with corresponding match data (or noted as unmatched)

        """
        # Verify requested DealElement is plural (ends in 's') and is a recognized model.
        if (not hasattr(self.primary, f"get_{element_name.lower()}_elements") or
                not element_name.lower().endswith('s')):
            print(f"**ERROR**: Unrecognized Plural Deal Type: {element_name.lower()}.")
            return []

        # Get list of singular DealElements (type specified via parameters)
        source_data_elem = getattr(self.primary, f"get_{element_name.lower()}_elements")()
        comp_data_elem = getattr(self.comparison, f"get_{element_name.lower()}_elements")()

        # Build list of tuples to track mappings between src and cmp
        source_data = [DataMatch(id_set=elem.id_set, found=False, source_obj=elem, match_obj=None) for elem
                       in source_data_elem]
        comp_data = [DataMatch(id_set=elem.id_set, found=False, source_obj=elem, match_obj=None) for elem
                     in comp_data_elem]

        # Iterate through src data looking for matches in the comparison data
        for src_elem in source_data:
            for comp_elem in comp_data:

                # If comparison element already has been matched, skip comparing this element to the source
                if comp_elem.found:
                    continue

                # If the SRC is identical OR is a superset of the comparison, map the elements.
                if src_elem.id_set >= comp_elem.id_set:

                    # Map the CMP object to the SRC object
                    src_elem.found = True
                    src_elem.match_obj = comp_elem.source_obj

                    # Map the SRC object to the CMP object
                    comp_elem.found = True
                    comp_elem.match_obj = src_elem.source_obj

                    # For manual debugging purposes only... hence always FALSE
                    if details and False:
                        print(f"MATCH FOUND for {element_name}:\n   SRC:\n"
                              f"   {src_elem.id_set} ({src_elem.source_obj.seq_num})")
                        print(f"   COMP:\n   {src_elem.match_obj.id_set} ({src_elem.match_obj.seq_num})\n")

        # If details were requested, build and print a results table.
        if details:
            self.build_results_table(results=source_data)

        # Otherwise, just print a 1-line summary.
        else:
            matches = sum([1 for datum in source_data if datum.found])
            print(f"SUMMARY FOR '{element_name}': {matches} out of {len(source_data)} source elements matched.")

        return source_data

    @staticmethod
    def build_results_table(results: typing.List[DataMatch]) -> typing.NoReturn:
        """
        Build table of results

        :param results: List of DataMatch objects (generated by compare_and_map_singular_elements)

        :return: None

        """
        # Constants
        loc, name, index, path = "LOC", "Index", "Name", "Path"
        zero_out = 'None'
        src_label, comp_label = "SRC", "CMP"

        # Define table columns/headers and column formatting
        headers = [loc, name, path, index]
        table = prettytable.PrettyTable(headers)
        table.align[index] = 'c'
        table.align[path] = 'l'

        # Determine how many matches were found.
        matches = sum([1 for datum in results if datum.found])

        # Get type of element being reported
        label = results[0].source_obj.type

        # If there were results...
        if results is not None:

            # Add a row for each SOURCE element
            for index, datum in enumerate(results):
                table.add_row(
                    [src_label, datum.source_obj.index, datum.source_obj.xpath, datum.source_obj.name]
                )

                # If a match was found, add a row for the match
                if datum.match_obj is not None:
                    table.add_row([comp_label, datum.match_obj.index, datum.match_obj.xpath, datum.match_obj.name])

                    # If it is not the last result in the last, add a blank row
                    if index < len(results) - 1:
                        table.add_row(['' for _ in range(len(headers))])

                # No matches were found for this element (but other elements did have a match), so
                # indicate the COMP file did not have a match for this result.
                elif matches > 0:
                    row_data = [comp_label, zero_out]
                    row_data.extend(['' for _ in range(len(headers) - 2)])
                    table.add_row(row_data)

                    # If it is not the last result in the last, add a blank row
                    if index < len(results) - 1:
                        table.add_row(['' for _ in range(len(headers))])

            # Print title and summary of table and then the table itself.
            print(f"'{label}' Element Type: {matches} OF {len(results)} MATCHED.")
            print(f"{table.get_string()}\n\n")

        # Code should never get here...
        # But need to output something (just in case) so, it is clear the routine did execute.
        else:
            label = results[0].source_obj.type
            print(f"'{label}' Element type: No results to display.\n")
